Scheduler assigns pod
        â†“
API server stores pod
        â†“
kubelet sees pod assigned to node
        â†“
CNI: setup pod network, assign IP
        â†“
CRI: create and run containers
        â†“
CSI: mount volumes if needed
        â†“
kube-proxy: configure service load balancing



â­ CRI = run containers
containerd, CRI-O
kubelet â†’ CRI API â†’ runtime
Handles images + containers

â­ CNI = network for pods
Calico, Flannel, Cilium, Weave
Assigns Pod IP
Creates routes
Enforces NetworkPolicies

â­ CSI = storage for pods
AWS EBS CSI, GCE PD CSI, Ceph RBD
Dynamic provisioning
PV and PVC

â­ kube-proxy = service networking
Implements ClusterIP, NodePort, LoadBalancer
Uses iptbles or IPVS
Load-balances traffic across Pods


| Feature                     | CNI                | kube-proxy |
| --------------------------- | ------------------ | ---------- |
| Assign Pod IPs              | âœ”                  | âŒ          |
| Configure pod routing       | âœ”                  | âŒ          |
| Enforce NetworkPolicies     | âœ” (Calico, Cilium) | âŒ          |
| Service routing (ClusterIP) | âŒ                  | âœ”          |
| NodePort rules              | âŒ                  | âœ”          |
| Load-balancing to pods      | âŒ                  | âœ”          |
| Use iptables/IPVS           | âŒ                  | âœ”          |




ğŸŸ¦ REAL EXAMPLE: Pod-to-Pod Traffic
Pod A (192.168.1.10)  â†’  Pod B (192.168.1.15)
CNI does all the work:
assigns IPs
configures routes
ensures connectivity
kube-proxy is NOT involved.

ğŸŸ¥ REAL EXAMPLE: Service-to-Pod Traffic (ClusterIP)
curl my-service
This uses:
1ï¸âƒ£ DNS â†’ CoreDNS
2ï¸âƒ£ kube-proxy â†’ iptables/IPVS rules
3ï¸âƒ£ Actual packet â†’ Sent to backend pod

Flow:
DNS â†’ kube-proxy rules â†’ Pod IP
